import { Brand } from "@effect/data/Brand";
import * as S from "@effect/schema";
import { pipe } from "fp-ts/lib/function.js";
import { nanoid } from "nanoid";

/**
 * Evolu Id is a globally unique branded string created by Nano ID.
 *
 * @link https://github.com/ai/nanoid.
 */
export const Id = pipe(S.string, S.pattern(/^[\w-]{21}$/), S.brand("Id"));
export type Id = S.Infer<typeof Id>;

/**
 * A factory function that creates branded Evolu Id schema.
 *
 * Strings with different branding types are not interchangeable,
 * even though they have the same underlying representation.
 *
 * @example
 * import * as S from "@effect/schema";
 * import { id } from "evolu";
 *
 * const TodoId = id("Todo");
 * // type TodoId = string & Brand<"Id"> & Brand<"Todo">
 * type TodoId = S.Infer<typeof TodoId>;
 *
 * if (S.is(TodoId)(1)) ...
 */
export const id = <T extends string>(table: T): S.Schema<Id & Brand<T>> =>
  pipe(Id, S.brand(table));

/**
 * A factory function that creates branded Evolu Id.
 *
 * @example
 * import { createId } from "evolu";
 * // const todoId: string & Brand<"Id"> & Brand<"Todo">
 * const todoId = createId<'Todo'>();
 */
export const createId = <T extends string>(): Id & Brand<T> =>
  nanoid() as Id & Brand<T>;

/**
 * Mnemonic is a password generated by Evolu in BIP39 format.
 *
 * A mnemonic, also known as a "seed phrase," is a set of 12 words in a
 * specific order chosen from a predefined list. The purpose of the BIP39
 * mnemonic is to provide a human-readable way of storing a private key.
 */
export type Mnemonic = string & Brand<"Mnemonic">;

/**
 * OwnerId is the current user's ID safely derived from its Mnemonic.
 */
export type OwnerId = Id & Brand<"Owner">;

/**
 * Evolu database owner.
 */
export interface Owner {
  readonly id: OwnerId;
  readonly mnemonic: Mnemonic;
}

/**
 * SQLite doesn't support the boolean type, so Evolu uses SqliteBoolean instead.
 * Use the 'cast' helper to cast SqliteBoolean from boolean and back.
 * https://www.sqlite.org/quirks.html#no_separate_boolean_datatype
 */
export const SqliteBoolean = S.union(S.literal(0), S.literal(1));
export type SqliteBoolean = S.Infer<typeof SqliteBoolean>;

/**
 * SQLite doesn't support the Date type, so Evolu uses SqliteDate instead.
 * Use the 'cast' helper to cast SqliteDate from Date and back.
 * https://www.sqlite.org/quirks.html#no_separate_datetime_datatype
 */
export const SqliteDate = pipe(
  S.string,
  S.filter((s) => !isNaN(Date.parse(s)), {
    message: () => "a date as a string value in ISO format",
    identifier: "SqliteDate",
  }),
  S.brand("SqliteDate")
);
export type SqliteDate = S.Infer<typeof SqliteDate>;

/**
 * A helper for casting types not supported by SQLite.
 * SQLite doesn't support Date nor Boolean types, so Evolu emulates them
 * with `SqliteBoolean` and `SqliteDate`.
 *
 * @example
 * .where("isDeleted", "is not", cast(true))
 */
export function cast(value: boolean): SqliteBoolean;
export function cast(value: SqliteBoolean): boolean;
export function cast(value: Date): SqliteDate;
export function cast(value: SqliteDate): Date;
export function cast(
  value: boolean | SqliteBoolean | Date | SqliteDate
): boolean | SqliteBoolean | Date | SqliteDate {
  if (typeof value === "boolean") return value === true ? 1 : 0;
  if (typeof value === "number") return value === 1;
  if (value instanceof Date) return value.toISOString() as SqliteDate;
  return new Date(value);
}

/**
 * A branded string that represents a string with a maximum length
 * of 1000 characters.
 *
 * @example
 * import * as S from "@effect/schema";
 * import * as E from "evolu";
 *
 * if (!S.is(E.String1000)(unknownValue)) return;
 */
export const String1000 = pipe(
  S.string,
  S.maxLength(1000),
  S.brand("String1000")
);
export type String1000 = S.Infer<typeof String1000>;

/**
 * A branded string that represents a nonempty string with a maximum length
 * of 1000 characters.
 *
 * @example
 * import * as S from "@effect/schema";
 * import * as E from "evolu";
 *
 * if (!S.is(E.NonEmptyString1000)(unknownValue)) return;
 */
export const NonEmptyString1000 = pipe(
  S.string,
  S.minLength(1),
  S.maxLength(1000),
  S.brand("NonEmptyString1000")
);
export type NonEmptyString1000 = S.Infer<typeof NonEmptyString1000>;
