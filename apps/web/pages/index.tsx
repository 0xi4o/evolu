import { createHooks, getOwner, model, resetOwner, restoreOwner } from "evolu";

// Every table needs its own branded string ID.
// Branded types is a TypeScript feature to distinguish primitive types.
const TodoId = model.id<"todo">();
type TodoId = model.infer<typeof TodoId>;

// Define database schema and create `useQuery` and `useMutation` React Hooks.
const { useQuery, useMutation } = createHooks({
  todo: {
    id: TodoId,
    // While it's possible to use just string, we don't recommend it.
    // NonEmptyString1000 is a non-empty string with a maximum of 1000 chars.
    title: model.NonEmptyString1000,
    // SQLite has no Boolean datatype, so we emulate it.
    isCompleted: model.SqliteBoolean,
  },
});

const TodoItem = ({
  row: { id, title, isCompleted },
}: {
  readonly row: {
    readonly id: TodoId;
    readonly title: model.NonEmptyString1000 | null;
    readonly isCompleted: model.SqliteBoolean | null;
  };
}): JSX.Element => {
  const { mutate } = useMutation();

  const handleCompleteClick = (): void => {
    mutate("todo", { id, isCompleted: !isCompleted });
  };

  const handleRenameClick = (): void => {
    const newTitle = model.NonEmptyString1000.safeParse(
      prompt("What needs to be done?", title || "")
    );
    if (!newTitle.success) {
      alert(JSON.stringify(newTitle.error, null, 2));
      return;
    }
    mutate("todo", { id, title: newTitle.data });
  };

  const handleDeleteClick = (): void => {
    mutate("todo", { id, isDeleted: true });
  };

  return (
    <li>
      <p
        style={{
          textDecoration: isCompleted ? "Line-through" : "none",
        }}
      >
        {title}
      </p>
      <button onClick={handleCompleteClick}>
        {isCompleted ? "completed" : "complete"}
      </button>
      <button onClick={handleRenameClick}>rename</button>
      <button onClick={handleDeleteClick}>delete</button>
    </li>
  );
};

export default function Web(): JSX.Element {
  const { rows } = useQuery((db) =>
    // Note typed SQL query via https://github.com/koskimas/kysely.
    db
      .selectFrom("todo")
      .select(["id", "title", "isCompleted"])
      // Note auto-generated (isDeleted, createdAt) columns.
      .where("isDeleted", "is not", model.cast(true))
      .orderBy("createdAt")
  );

  const { mutate } = useMutation();

  const handleAddTodoClick = (): void => {
    const title = model.NonEmptyString1000.safeParse(
      prompt("What needs to be done?")
    );
    if (!title.success) {
      alert(JSON.stringify(title.error, null, 2));
      return;
    }
    // Add new todo. Note UI is updated automatically.
    mutate("todo", { title: title.data });
  };

  const handleShowMnemonic = (): void => {
    getOwner().then((owner) => {
      alert(owner.mnemonic);
    });
  };

  const handleResetOwner = (): void => {
    if (confirm("Are you sure? It will delete all your local data."))
      resetOwner();
  };

  const handleRestoreOwner = (): void => {
    const mnemonic = prompt("Your Mnemonic");
    if (mnemonic == null) return;
    const either = restoreOwner(mnemonic);
    if (either._tag === "Left") alert(JSON.stringify(either.left, null, 2));
  };

  return (
    <div>
      <h1>Evolu TodoMVC</h1>
      <ul>
        {rows.map((row) => (
          <TodoItem key={row.id} row={row} />
        ))}
      </ul>
      <p>
        <button onClick={handleAddTodoClick}>Add Todo</button>
      </p>
      <p>
        <button onClick={handleShowMnemonic}>Show Mnemonic</button>
        <button onClick={handleResetOwner}>Reset Owner</button>
        <button onClick={handleRestoreOwner}>Restore Owner</button>
      </p>
      <p>
        Mnemonic is your password generated by Evolu. Try it on another device.
      </p>
    </div>
  );
}
